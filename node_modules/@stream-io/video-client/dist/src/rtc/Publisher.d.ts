import { StreamSfuClient } from '../StreamSfuClient';
import { TrackInfo, TrackType } from '../gen/video/sfu/models/models';
import { CallState } from '../store';
import { PublishOptions } from '../types';
import { Dispatcher } from './Dispatcher';
import { VideoLayerSetting } from '../gen/video/sfu/event/events';
export type PublisherConstructorOpts = {
    sfuClient: StreamSfuClient;
    state: CallState;
    dispatcher: Dispatcher;
    connectionConfig?: RTCConfiguration;
    isDtxEnabled: boolean;
    isRedEnabled: boolean;
    onUnrecoverableError?: () => void;
    logTag: string;
};
/**
 * The `Publisher` is responsible for publishing/unpublishing media streams to/from the SFU
 *
 * @internal
 */
export declare class Publisher {
    private readonly logger;
    private pc;
    private readonly state;
    private readonly transceiverRegistry;
    private readonly publishOptionsPerTrackType;
    /**
     * An array maintaining the order how transceivers were added to the peer connection.
     * This is needed because some browsers (Firefox) don't reliably report
     * trackId and `mid` parameters.
     *
     * @internal
     */
    private readonly transceiverInitOrder;
    private readonly trackKindMapping;
    private readonly trackLayersCache;
    private readonly isDtxEnabled;
    private readonly isRedEnabled;
    private readonly unsubscribeOnIceRestart;
    private readonly onUnrecoverableError?;
    private isIceRestarting;
    /**
     * The SFU client instance to use for publishing and signaling.
     */
    sfuClient: StreamSfuClient;
    /**
     * Constructs a new `Publisher` instance.
     *
     * @param connectionConfig the connection configuration to use.
     * @param sfuClient the SFU client to use.
     * @param state the call state to use.
     * @param dispatcher the dispatcher to use.
     * @param isDtxEnabled whether DTX is enabled.
     * @param isRedEnabled whether RED is enabled.
     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE once connection goes to `disconnected` state.
     * @param onUnrecoverableError a callback to call when an unrecoverable error occurs.
     * @param logTag the log tag to use.
     */
    constructor({ connectionConfig, sfuClient, dispatcher, state, isDtxEnabled, isRedEnabled, onUnrecoverableError, logTag, }: PublisherConstructorOpts);
    private createPeerConnection;
    /**
     * Closes the publisher PeerConnection and cleans up the resources.
     */
    close: ({ stopTracks }: {
        stopTracks: boolean;
    }) => void;
    /**
     * Detaches the event handlers from the `RTCPeerConnection`.
     * This is useful when we want to replace the `RTCPeerConnection`
     * instance with a new one (in case of migration).
     */
    detachEventHandlers: () => void;
    /**
     * Starts publishing the given track of the given media stream.
     *
     * Consecutive calls to this method will replace the stream.
     * The previous stream will be stopped.
     *
     * @param mediaStream the media stream to publish.
     * @param track the track to publish.
     * @param trackType the track type to publish.
     * @param opts the optional publish options to use.
     */
    publishStream: (mediaStream: MediaStream, track: MediaStreamTrack, trackType: TrackType, opts?: PublishOptions) => Promise<void>;
    /**
     * Stops publishing the given track type to the SFU, if it is currently being published.
     * Underlying track will be stopped and removed from the publisher.
     * @param trackType the track type to unpublish.
     * @param stopTrack specifies whether track should be stopped or just disabled
     */
    unpublishStream: (trackType: TrackType, stopTrack: boolean) => Promise<void>;
    /**
     * Returns true if the given track type is currently being published to the SFU.
     *
     * @param trackType the track type to check.
     */
    isPublishing: (trackType: TrackType) => boolean;
    private notifyTrackMuteStateChanged;
    /**
     * Stops publishing all tracks and stop all tracks.
     */
    private stopPublishing;
    updateVideoPublishQuality: (enabledLayers: VideoLayerSetting[]) => Promise<void>;
    /**
     * Returns the result of the `RTCPeerConnection.getStats()` method
     * @param selector
     * @returns
     */
    getStats: (selector?: MediaStreamTrack | null | undefined) => Promise<RTCStatsReport>;
    private getCodecPreferences;
    private onIceCandidate;
    /**
     * Sets the SFU client to use.
     *
     * @param sfuClient the SFU client to use.
     */
    setSfuClient: (sfuClient: StreamSfuClient) => void;
    /**
     * Restarts the ICE connection and renegotiates with the SFU.
     */
    restartIce: () => Promise<void>;
    private onNegotiationNeeded;
    /**
     * Initiates a new offer/answer exchange with the currently connected SFU.
     *
     * @param options the optional offer options to use.
     */
    private negotiate;
    private enableHighQualityAudio;
    private mungeCodecs;
    private extractMid;
    /**
     * Returns a list of tracks that are currently being published.
     *
     * @internal
     * @param sdp an optional SDP to extract the `mid` from.
     */
    getAnnouncedTracks: (sdp?: string) => TrackInfo[];
    private onIceCandidateError;
    private onIceConnectionStateChange;
    private onIceGatheringStateChange;
    private onSignalingStateChange;
    private ridToVideoQuality;
}
